%defines
%{

	#pragma warning(disable: 4996)

	#include <stdio.h>
	#include <stdlib.h>
	#include "globals.h"
	#include "functions.h"
	
	#define YYDEBUG 1

	int g_errors;

	struct loop_addr{
	  int start_loop_addr;
	  int end_loop_addr;
	};

	struct loop_addr* create_loop_addr(){
	  return (struct loop_addr *) malloc(sizeof(struct loop_addr));
	}

	// Will be generated by flex
	extern int yylex();

	extern void yyerror(char const* p_msg);

%}
%union cell{
	struct bfpp_datatype* m_datatype;
	struct loop_addr* m_loop_addr;
	int m_int;
}
%start program
%token MOVR MOVL
%token INCR DECR
%token WRITE READ
%token<m_loop_addr> OPEN_BLK
%token CLOSE_BLK
%token<m_datatype> INTEGER 
%token<m_datatype> FLOAT 
%token<m_datatype> STRING
%token<m_loop_addr> IF_START 
%token<m_loop_addr> IF_BLK
%token ELSE_START
%token TO_INT TO_FLOAT TO_STRING
%token<m_int> LT 
%token<m_int> GT 
%token<m_int> EQ
%%

program:	/* empty */
	|	exprs
	;

exprs: exprs expr
	| expr
	;

expr:	nav
	|	INCR		{ store_code(P_INCR, 0); }
	|	DECR		{ store_code(P_DECR, 0); }
	|	WRITE		{ store_code(P_WRITE, 0); }
	|	READ		{ store_code(P_READ, 0); }
	|	values
	|	conversions
	|	if_cond
	|	loop
	;

nav:	MOVR		{ store_code(P_MOVR, 0); }
	|	MOVL		{ store_code(P_MOVL, 0); }
	;

values: INTEGER		{ store_code(P_VAL, $1); }
	|	 FLOAT 		{ store_code(P_VAL, $1); }
	|	 STRING  	{ store_code(P_VAL, $1);}
	;

conversions: TO_INT	{ struct bfpp_datatype* conv = malloc(sizeof(struct bfpp_datatype));
					  conv->m_type = 'I';
					  conv->data.m_int = 0;
					  store_code(P_CONV, conv); }
	| TO_FLOAT		{ struct bfpp_datatype* conv = malloc(sizeof(struct bfpp_datatype));
					  conv->m_type = 'I';
					  conv->data.m_int = 1;
					  store_code(P_CONV, conv); }
	| TO_STRING		{ struct bfpp_datatype* conv = malloc(sizeof(struct bfpp_datatype));
					  conv->m_type = 'I';
					  conv->data.m_int = 2;
					  store_code(P_CONV, conv); }
	;

if_cond:	IF_START	{ $1 = create_loop_addr();
						  $1->start_loop_addr = get_code_itr();
						  reserve_loc(); }
				rel_op values	
			IF_BLK	
				exprs
			IF_BLK	{ $5 = create_loop_addr();
						  $5->start_loop_addr = get_code_itr();
						  reserve_loc(); }

			ELSE_START	{ $1->end_loop_addr = get_code_itr();
						  struct bfpp_datatype* end_loop_one = malloc(sizeof(struct bfpp_datatype));
						  end_loop_one->m_type = 'I';
						  end_loop_one->data.m_int = $1->end_loop_addr;

						  back_patch($1->start_loop_addr, P_IF_COND, end_loop_one); }
			IF_BLK
				exprs
			IF_BLK	{ $5->end_loop_addr = get_code_itr();
						  struct bfpp_datatype* end_loop_six = malloc(sizeof(struct bfpp_datatype));
						  end_loop_six->m_type = 'I';
						  end_loop_six->data.m_int = $5->end_loop_addr;

						  back_patch($5->start_loop_addr, P_JUMP_COND, end_loop_six); }
	;

rel_op: EQ		{	struct bfpp_datatype* rel = malloc(sizeof(struct bfpp_datatype));
					rel->m_type = 'I';
					rel->data.m_int = 0;
				
					store_code(P_REL_OP, rel); }

	|	LT		{	struct bfpp_datatype* rel = malloc(sizeof(struct bfpp_datatype));
					rel->m_type = 'I';
					rel->data.m_int = 1;
				
					store_code(P_REL_OP, rel); }

	|	GT		{	struct bfpp_datatype* rel = malloc(sizeof(struct bfpp_datatype));
					rel->m_type = 'I';
					rel->data.m_int = 2;
				
					store_code(P_REL_OP, rel); }
	;

loop:	block
	;

block:	OPEN_BLK	{ $1 = create_loop_addr();
					  $1->start_loop_addr = get_code_itr();
					  reserve_loc(); }
			exprs	
		CLOSE_BLK	{ $1->end_loop_addr = get_code_itr();
						struct bfpp_datatype* end_loop = malloc(sizeof(struct bfpp_datatype));
						end_loop->m_type = 'I';
						end_loop->data.m_int = $1->end_loop_addr;

						struct bfpp_datatype* start_loop = malloc(sizeof(struct bfpp_datatype));
						start_loop->m_type = 'I';
						start_loop->data.m_int = $1->start_loop_addr;

						store_code(P_JUMP_COND, start_loop);
						back_patch($1->start_loop_addr, P_COND, end_loop);	
					}
	;

%%

int main(int argc, char* argv[]) {
	extern FILE *yyin;

	++argv;
	--argc;

	yyin = fopen(argv[0], "r");

	/* yydebug = 1; */
	g_errors = 0;
	yyparse();

	printf("Parse Completed\n");

	if (g_errors == 0) {
		create_bf_cells(100);
		//print_code();
		fetch_execute_cycle();
		//clean_cells();
	}

	return 0;
}

void yyerror(char const* p_msg){
	printf("Syntax error: %s\n", p_msg);
}